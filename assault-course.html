<script>
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const scoreDisplay = document.getElementById('score');
  const gameOverScreen = document.getElementById('game-over');
  const finalScoreDisplay = document.getElementById('final-score');
  const restartBtn = document.getElementById('restart-btn');

  // Game variables
  let block = { x: 100, y: 300, size: 30, velocity: 0, gravity: 0.5, jump: -10 };
  let pillars = [];
  let score = 0;
  let gameRunning = true;
  const pillarWidth = 50;
  const pillarSpeed = 2;
  let frameCount = 0;

  // Gap settings
  const minGap = block.size * 3;  // minimum 3 blocks tall (90px)
  const maxGap = 250;             // maximum gap (easier play)

  // High score
  let highScore = localStorage.getItem('assaultCourseHighScore') || 0;
  scoreDisplay.textContent = `Score: ${score} | High: ${highScore}`;

  function updateHighScore() {
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('assaultCourseHighScore', highScore);
      scoreDisplay.textContent = `Score: ${score} | High: ${highScore}`;
    }
  }

  // Add pillar
  function addPillar() {
    // randomize gap size between minGap and maxGap
    const gapSize = Math.random() * (maxGap - minGap) + minGap;

    // keep the whole gap inside the canvas
    const minGapY = 50;
    const maxGapY = canvas.height - gapSize - 50;
    const gapY = Math.random() * (maxGapY - minGapY) + minGapY;

    pillars.push({ x: canvas.width, gapY: gapY, gapSize: gapSize, passed: false });
  }

  // Handle input
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && gameRunning) {
      block.velocity = block.jump;
    }
  });
  canvas.addEventListener('click', () => {
    if (gameRunning) {
      block.velocity = block.jump;
    }
  });

  // Restart game
  restartBtn.addEventListener('click', () => {
    block.y = 300;
    block.velocity = 0;
    pillars = [];
    score = 0;
    scoreDisplay.textContent = `Score: ${score} | High: ${highScore}`;
    gameOverScreen.style.display = 'none';
    gameRunning = true;
    frameCount = 0;
    addPillar();
    gameLoop();
  });

  // Game loop
  function gameLoop() {
    if (!gameRunning) return;

    // Update block
    block.velocity += block.gravity;
    block.y += block.velocity;
    if (block.y + block.size > canvas.height || block.y < 0) {
      endGame();
    }

    // Update pillars
    if (frameCount % 90 === 0) {
      addPillar();
    }
    pillars.forEach(pillar => {
      pillar.x -= pillarSpeed;
      // Check collision
      if (
        block.x + block.size > pillar.x &&
        block.x < pillar.x + pillarWidth &&
        (block.y < pillar.gapY || block.y + block.size > pillar.gapY + pillar.gapSize)
      ) {
        endGame();
      }
      // Score points
      if (!pillar.passed && block.x > pillar.x + pillarWidth) {
        score++;
        scoreDisplay.textContent = `Score: ${score} | High: ${highScore}`;
        pillar.passed = true;
      }
    });
    pillars = pillars.filter(pillar => pillar.x + pillarWidth > 0);

    // Draw
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw block
    ctx.fillStyle = '#ff0000';
    ctx.shadowColor = 'var(--fg)';
    ctx.shadowBlur = 10;
    ctx.fillRect(block.x, block.y, block.size, block.size);
    ctx.shadowBlur = 0;
    // Draw pillars
    ctx.fillStyle = 'var(--fg)';
    pillars.forEach(pillar => {
      ctx.fillRect(pillar.x, 0, pillarWidth, pillar.gapY);
      ctx.fillRect(pillar.x, pillar.gapY + pillar.gapSize, pillarWidth, canvas.height);
    });

    frameCount++;
    requestAnimationFrame(gameLoop);
  }

  function endGame() {
    gameRunning = false;
    gameOverScreen.style.display = 'block';
    finalScoreDisplay.textContent = score;
    updateHighScore();
  }

  // Start game
  addPillar();
  gameLoop();
</script>
